"0","########################################################################"
"0","### EXAMPLE 6.6 HIGH DIMENSIONAL DISTRIBUTION"
"0","#########################################################################"
"0","# p = number of dimensions"
"0","# n = number of points sampled"
"0","# N.eff = effective sample size"
"0","# X = sample"
"0","# w = importance weights"
"0","# rejuvs = number of rejuvenations"
"0","# normal.draw = sample from the standard normal envelope."
"0","# ftxt = f_t(x_1:t) in book notation"
"0","# ft1xt1= f_t-1(x_1:t-1)"
"0","# Note: f_t(x_t|x_1:t-1) = ftxt/ft1xt1"
"0","#########################################################################"
"0",""
"0","##INITIAL VALUES"
"0","p = 50 # n. of parameters"
"0","n = 5000 # n. of obs."
"0",""
"0","# sample X_t at time t corresponds to column in matrix X"
"0","# the i'th row is X_{1:p}^(i)"
"0","X = matrix(NA, nrow = n, ncol = p) "
"0",""
"0","w = rep(1, n) / n # initialize weights with uniform 1/n"
"0","N.eff = rep(NA, p + 1)"
"0","N.eff[1] = n # corresponds to uniform weight distribution"
"0","ft1xt1 = w"
"0","rejuvs = 0"
"0",""
"0","# store weights"
"0","ws = matrix(NA, nrow = n, ncol = p)  # making a weight matrix"
"0","# target density function"
"0","dens.fun = function(x) {"
"0","  temp = function(x) {"
"0","    exp(-(abs(sqrt(sum(x ** 2))) ** 3) / 3) # the target density "
"0","  }"
"0","  # apply the above density function temp to each row (dimension ""1"") of matrix x"
"0","  # i.e. compute value of density function across all samples"
"0","  c(apply(x, 1, temp))"
"0","}"
"0",""
"0","# 1D variant of above"
"0","dens.fun.1 = function(x) {"
"0","  exp(-(abs(sqrt(x ** 2)) ** 3) / 3)"
"0","}"
"0","ncoeff = integrate(dens.fun.1, -999, 999)$value"
"0","dens.fun.1.n = function(x) {"
"0","  dens.fun.1(x) / ncoeff"
"0","}"
"0",""
"0",""
"0",""
"0",""
"0","##MAIN LOOP"
"0","set.seed(4567)"
"0","# loop over dimensions / time steps"
"0","for (i in 1:p) { "
"0","  # Generate new sample: n points x_t^(i) from the envelope function N(0,1)"
"0","  normal.draw = rnorm(n, mean = 0, sd = 1) "
"0","  "
"0","  # Compute values of the target density at x_{1:t}"
"0","  if (i == 1) {"
"0","    # At first time step, compute a one-dimensional distribution"
"0","    ftxt = dens.fun(cbind(normal.draw))"
"0","  } else {"
"0","    # At later time steps, append new sample to previous to make X_t"
"0","    Xtemp = cbind(X[, 1:(i - 1)], normal.draw) "
"0","    ftxt = dens.fun(Xtemp)"
"0","  }"
"0","  # Store new sample to i'th col of matrix X"
"0","  X[, i] = normal.draw "
"0","  "
"0","  # See comment (*)"
"0","  #calculate the weight adjustment factor"
"0","  w = w * ftxt / (ft1xt1 * dnorm(normal.draw))"
"0","  "
"0","  # Store values at current time step to ft1xt1"
"0","  ft1xt1 = ftxt"
"0","  "
"0","  # Normalize and store weights"
"0","  w = w / sum(w)"
"0","  ws[, i] = w"
"0","  "
"0","  # Compute effective sample size"
"0","  N.eff[i + 1] = 1 / sum(w ** 2)"
"0","  "
"0","  # If ESS is less than predetermined threshold - here 1/5 of sample size,"
"0","  # perform resampling/rejuvenation"
"0","  if (N.eff[i + 1] < N.eff[1] / 5) {"
"0","    rejuvs = rejuvs + 1"
"0","    "
"0","    # Sample indices j from (1,...,n) with replacement, with probabilities w_j"
"0","    idx = sample(1:n, n, replace = T, prob = w)"
"0","    "
"0","    # Keep rows corresponding to indices idx from sample matrix X"
"0","    X = X[idx,]"
"0","    "
"0","    # Re-compute density function"
"0","    ft1xt1 = dens.fun(X[, 1:i])"
"0","    "
"0","    # Reset sample weights"
"0","    w = rep(1, n) / n"
"0","  }"
"0","}"
"0",""
"0",""
