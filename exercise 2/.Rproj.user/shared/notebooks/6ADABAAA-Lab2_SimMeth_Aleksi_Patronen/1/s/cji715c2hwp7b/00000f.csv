"0","# I didint have any code in my version of the book(or atleast didint find any), so I used code from the slides."
"0",""
"0","## PARAMETERS"
"0","# tmax = limit on t index"
"0","# n = number of Monte Carlo samples"
"0","# rejuvs = number of rejuvenations used"
"0","# ess = effective sample size"
"0","# w = importance weights"
"0","# X = samples"
"0","# Xt = current sample of X_t | X_(t-1)"
"0","# sds = sequence of estimates of sigma"
"0",""
"0",""
"0","##INITIAL VALUES"
"0","tmax = 100 # amount cycle s"
"0","n = 100000 # n. obs"
"0","X = matrix(0,n,tmax+1) # filled with zeros for init. observations with n obs. and t + 1parameters"
"0","w = matrix(0,n,tmax+1) # weight matrix init. to zero"
"0","w[,1] = rep(1/n,n) # init weight as  1/n"
"0","ess = rep(0,tmax) # effective sample size"
"0","rejuvs = 0 # number of times the algorithm is rejuvenated for record keeping"
"0",""
"0",""
"0","##MAIN LOOP"
"0","set.seed(919191) # setting seed for reproducability in sampling"
"0","for (i in 1:tmax) { # starting the for loop "
"0","     Xt = rnorm(n,X[,i],rep(1.5,n)) # sample from normal distr. n times, with mean as zero, and sd = 1,5"
"0","     u = abs(cos(Xt-X[,i]))*exp(-.25*abs(Xt-X[,i])^2)/ # calculate the weight adjustment factor."
"0","       (dnorm(Xt,X[,i],rep(1.5,n))) "
"0","     w[,i+1] = w[,i]*u # weights themselfs"
"0","     w[,i+1] = w[,i+1]/sum(w[,i+1]) # norm the weights so they sum to one"
"0","     ess[i] = 1/sum(w[,i+1]^2) # calculate effective sample size"
"0","     if (ess[i]<.33*n) { # if ess is too small i.e. the sampling has become too degeneritive, we restart with new weights"
"0","          Xt = sample(Xt,n,prob=w[,i+1],replace=T) #sample with replacement from Xt, n time, with probability of the weigths"
"0","          rejuvs = rejuvs+1  # when ess is too small we rejuvinate, this is for record keeping"
"0","          w[,i+1] = rep(1/n,n)  # restart the weights with the same init as before."
"0","     }"
"0","     X[,i+1] = Xt  # if ess is alright then keep going."
"0","}"
